<?php

/**
 * @file
 * Main module file for EIC Flags module.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\Session\AccountInterface;
use Drupal\eic_flags\Form\RequestCloseForm;
use Drupal\eic_flags\Form\NewRequestForm;
use Drupal\eic_flags\Hooks\FlagTokens;
use Drupal\eic_flags\RequestStatus;
use Drupal\eic_flags\RequestTypes;
use Drupal\eic_flags\Routing\EntityRequestRouteProvider;
use Drupal\eic_flags\Service\HandlerInterface;

/**
 * Implements hook_theme().
 */
function eic_flags_theme() {
  return [
    'eic_flag_count' => [
      'variables' => [
        'attributes' => [],
        'title' => NULL,
        'action' => 'flag',
        'flag' => NULL,
        'flaggable' => NULL,
      ],
    ],
    'eic_flag_count_text' => [
      'variables' => [
        'title' => NULL,
        'flag_count' => NULL,
        'flag_id' => NULL,
      ],
    ],
  ];
}

/**
 * Implements hook_form_FORM_ID_alter() for the list_builder_filters form.
 *
 * Since the exposed form is a GET form, we don't want it to send the form
 * tokens. However, you cannot make this happen in the form builder function
 * itself, because the tokens are added to the form after the builder function
 * is called. So, we have to do it in a form_alter.
 *
 * @see \Drupal\eic_flags\Form\ListBuilderFilters
 */
function eic_flags_form_list_builder_filters_alter(
  &$form,
  FormStateInterface $form_state
) {
  $form['form_build_id']['#access'] = FALSE;
  $form['form_token']['#access'] = FALSE;
  $form['form_id']['#access'] = FALSE;
}

/**
 * Implements hook_cron().
 */
function eic_flags_cron() {
  $queue = \Drupal::service('queue')->get('eic_flags_notify_queue');
  $five_minutes_ago = strtotime('-5 minutes');
  $ten_minutes_ago = strtotime('-10 minutes');
  $database = \Drupal::database();
  $query = $database->select('flagging', 'f');
  $query->condition('f.created', $five_minutes_ago, '>');
  $query->condition('f.created', $ten_minutes_ago, '<');
  $query->fields('f', ['flag_id', 'entity_type', 'entity_id']);
  $query->distinct(TRUE);
  $result = $query->execute()->fetchAll();
  foreach ($result as $row) {
    $row = (array) $row;
    $queue->createItem($row);
  }
}

/**
 * Returns an array of allowed values for field 'field_request_status'
 */
function eic_flags_field_request_status_allowed_values() {
  return [
    RequestStatus::ACCEPTED => t('Accepted'),
    RequestStatus::ARCHIVED => t('Archived'),
    RequestStatus::DENIED => t('Denied'),
    RequestStatus::OPEN => t('Open'),
  ];
}

/**
 * Implements hook_entity_type_build().
 *
 * @var \Drupal\Core\Entity\EntityTypeInterface[] $entity_types
 */
function eic_flags_entity_type_build(array &$entity_types) {
  /** @var \Drupal\eic_flags\Service\HandlerInterface $delete_request_handler */
  $delete_request_handler = \Drupal::service('eic_flags.handler_collector')
    ->getHandlerByType(RequestTypes::DELETE);

  $supported_entities = array_keys($delete_request_handler->getSupportedEntityTypes());
  foreach ($supported_entities as $entity_id) {
    if (!isset($entity_types[$entity_id])) {
      continue;
    }

    $entity_type = $entity_types[$entity_id];
    $handler_classes = $entity_type->getHandlerClasses();
    $route_providers = $handler_classes['route_provider'] ?? [];
    $route_providers['action-request'] = EntityRequestRouteProvider::class;

    $entity_type->setFormClass('new-request', NewRequestForm::class)
      ->setFormClass('close-request', RequestCloseForm::class)
      ->setHandlerClass('route_provider', $route_providers)
      ->setLinkTemplate(
        'new-request',
        '/request/{request_type}/' . $entity_id . '/{' . $entity_id . '}'
      )
      ->setLinkTemplate(
        'close-request',
        '/admin/community/' . $entity_id . '/{' . $entity_id . '}/request/{request_type}/close'
      );
  }
}

/**
 * Implements hook_token_info().
 */
function eic_flags_token_info() {
  $class = \Drupal::classResolver(FlagTokens::class);
  return $class->tokenInfo();
}

/**
 * Implements hook_tokens().
 */
function eic_flags_tokens(
  $type,
  $tokens,
  array $data,
  array $options,
  BubbleableMetadata $bubbleable_metadata
) {
  $class = \Drupal::classResolver(FlagTokens::class);
  return $class->tokens($type, $tokens, $data, $options, $bubbleable_metadata);
}

/**
 * Implements hook_entity_operation().
 */
function eic_flags_entity_operation(EntityInterface $entity) {
  if (!$entity instanceof ContentEntityInterface) {
    return [];
  }

  $operations = [];
  /** @var \Drupal\eic_flags\Service\RequestHandlerCollector $collector */
  $collector = \Drupal::service('eic_flags.handler_collector');
  if ($request_type = \Drupal::routeMatch()->getParameter('request_type')) {
    $handler = $collector->getHandlerByType($request_type);
    return $handler->getActions($entity);
  }

  $is_admin = \Drupal::service('router.admin_context')->isAdminRoute();
  if ($is_admin) {
    return $operations;
  }

  $handlers = $collector->getHandlers();
  foreach ($handlers as $handler) {
    if (!$entity->access('request-' . $handler->getType())
      || !$handler->supports($entity)) {
      continue;
    }

    $type = $handler->getType();
    $operations['request_' . $type] = [
      'title' => t('Request ' . $type),
      'url' => $entity->toUrl('new-request')
        ->setRouteParameter(
          'destination',
          \Drupal::request()->getRequestUri()
        )
        ->setRouteParameter('request_type', $type),
    ];
  }

  return $operations;
}

/**
 * Implements hook_entity_operation_alter().
 */
function eic_flags_entity_operation_alter(
  array &$operations,
  EntityInterface $entity
) {
  $route_name = \Drupal::routeMatch()->getRouteName();
  if ('eic_flags.flagged_entities.list' !== $route_name) {
    return;
  }

  $request_type = \Drupal::requestStack()
    ->getCurrentRequest()
    ->get('request_type');
  $handler = \Drupal::service('eic_flags.handler_collector')
    ->getHandlerByType($request_type);
  if (!$handler instanceof HandlerInterface || !$handler->supports($entity)) {
    return;
  }

  $operations = array_filter(
    $operations,
    function ($operation, $key) {
      return in_array(
        $key,
        [
          'deny_request',
          'accept_request',
          'archive_request',
          'edit',
        ]
      );
    },
    ARRAY_FILTER_USE_BOTH
  );
}

/**
 * Implements hook_entity_access().
 */
function eic_flags_entity_access(
  EntityInterface $entity,
  $operation,
  AccountInterface $account
) {
  if (!in_array($operation, ['request-delete', 'request-archive'])) {
    return AccessResult::neutral();
  }

  $type = explode('-', $operation)[1];
  /** @var \Drupal\eic_flags\Service\HandlerInterface $delete_request_handler */
  $handler = \Drupal::service('eic_flags.handler_collector')
    ->getHandlerByType($type);

  $entity_type_id = $entity->getEntityTypeId();
  $supported_entities = array_keys($handler->getSupportedEntityTypes());
  if (!in_array($entity_type_id, $supported_entities)) {
    return AccessResult::neutral();
  }

  // We allow requests only for certain roles.
  if (!$account->hasPermission('make ' . $type . ' request')) {
    return AccessResult::forbidden();
  }

  return AccessResult::allowed();
}
