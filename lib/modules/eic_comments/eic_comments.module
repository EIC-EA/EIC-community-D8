<?php

/**
 * @file
 * Main module file for EIC Comments module.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\eic_comments\Hooks\EntityOperations;
use Drupal\eic_groups\EICGroupsHelper;
use Drupal\flag\FlagInterface;
use Drupal\node\NodeForm;
use Drupal\node\NodeInterface;

/**
 * Implements hook_form_FORM_ID_alter().
 */
function eic_comments_form_comment_node_comment_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form_comment_body = &$form['comment_body']['widget'];

  $form['comment_body']['#attributes']['class'][] = 'ecl-comment-form__textarea-wrapper';
  $form_comment_body[0]['#title_display'] = 'invisible';

  array_push($form_comment_body[0]['#attributes']['class'],
  'ecl-text-area',
  'ecl-comment-form__textarea',
  'ecl-comment-form-reply'
  );
  $form_comment_body['#after_build'][] = 'eic_comments_configure_comment_form';

  $form["actions"]["submit"]["#value"] = t('Publish');
}

/**
 * Callback function to hide text format information.
 */
function eic_comments_configure_comment_form($form) {
  $form[0]['format']['#access'] = FALSE;
  return $form;
}

/**
 * Implements hook_entity_view().
 */
function eic_comments_entity_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {
  switch ($entity->getEntityTypeId()) {
    case 'node':
      \Drupal::classResolver(EntityOperations::class)
        ->entityView($build, $entity, $display, $view_mode);
      break;

  }
}

/**
 * Implements hook_form_alter().
 */
function eic_comments_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form_object = $form_state->getFormObject();

  // If we are not in a node form, we do nothing.
  if (!$form_object instanceof NodeForm) {
    return;
  }

  $entity = $form_object->getEntity();

  if (!$entity instanceof NodeInterface) {
    return;
  }

  $current_user = \Drupal::currentUser();
  $route_name = \Drupal::routeMatch()->getRouteName();
  $can_edit_comment_settings = FALSE;

  if ($entity->isNew()) {
    if ($route_name === 'entity.group_content.create_form') {
      $can_edit_comment_settings = TRUE;
    }
  }
  else {
    $group_contents = \Drupal::entityTypeManager()->getStorage('group_content')->loadByEntity($entity);

    if (!empty($group_contents)) {
      $group_content = reset($group_contents);
      $group = $group_content->getGroup();
      $groupType = $group->getGroupType();

      $installedContentPlugins = $groupType->getInstalledContentPlugins()->getInstanceIds();
      if (in_array("group_node:{$entity->bundle()}", $installedContentPlugins)) {
        $can_edit_comment_settings = EICGroupsHelper::userIsGroupAdmin($group, $current_user);
      }
    }
  }

  /** @var \Drupal\Core\Field\FieldDefinitionInterface[] $field_definitions */
  $field_definitions = \Drupal::service('entity_field.manager')->getFieldDefinitions('node', $entity->bundle());

  // We allow the user who is creating the node to be able to manage comment
  // settings. For existing nodes we only allow owners to manage comment
  // settings.
  foreach ($field_definitions as $field_definition) {
    if ($field_definition->getType() !== 'comment') {
      continue;
    }

    if (!isset($form[$field_definition->getName()])) {
      continue;
    }

    if (!isset($form[$field_definition->getName()]['#access'])) {
      continue;
    }

    // If the node is new, the user can manage comment settings.
    if ($entity->isNew()) {
      $form[$field_definition->getName()]['#access'] = TRUE;
      continue;
    }

    // If the node already exists, the owner or group admin can manage the
    // comment settings.
    if (!$entity->isNew() &&
      ($entity->getOwnerId() === $current_user->id() || $can_edit_comment_settings)
    ) {
      $form[$field_definition->getName()]['#access'] = TRUE;
    }
  }
}

/**
 * Implements hook_flag_action_access().
 */
function eic_comments_flag_action_access($action, FlagInterface $flag, AccountInterface $account, EntityInterface $flaggable = NULL) {
  $access = AccessResult::neutral();

  if (!$flaggable) {
    return $access;
  }

  switch ($flaggable->getEntityTypeId()) {
    case 'comment':
      // Deny access to flag/unflag the comment if the comment has been soft
      // deleted.
      // @todo Currently we cannot now if a comment has been archived without
      // looping through all request archivals. We should create a property or
      // a field to identify if a comment is archived.
      if (
        !$flaggable->get('field_comment_is_soft_deleted')->isEmpty() &&
        $flaggable->get('field_comment_is_soft_deleted')->value
      ) {
        $access = AccessResult::forbidden()
          ->addCacheableDependency($flaggable);
        break;
      }

      /** @var \Drupal\Core\Entity\EntityInterface $commented_entity */
      $commented_entity = $flaggable->getCommentedEntity();

      // If node is published, the access to flag/unflag the comment will be
      // neutral and might be allowed or denied by other modules.
      if (
        $commented_entity->isPublished() &&
        $commented_entity->access('view')
      ) {
        break;
      }

      // Deny access to flag/unflag the comment if the commented entity is not
      // published.
      $access = AccessResult::forbidden()
        ->addCacheableDependency($flaggable)
        ->addCacheableDependency($commented_entity);

      break;

  }

  return $access;
}
